<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css打钩实现]]></title>
    <url>%2F2018%2F10%2F04%2Fcss%E6%89%93%E9%92%A9%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[今天codepen上发现一个很有趣的打钩实现方式。通过设置块自身的宽高背景和box-shadow来叠加出 勾 的形状，无论如何如何还是实现出来了，感觉和我以前接触的大众的svg或者是border-width构建的思路不大一样。 See the Pen hook (box-shadow) by johnson (@johnsonee) on CodePen.]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按钮点击特效小试]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88%E5%B0%8F%E8%AF%95%2F</url>
    <content type="text"><![CDATA[水波纹点按效果（ripple effect）关于水波纹这个点击效果，我最早看到是在谷歌的Material Design中，最近在部门童鞋的某个项目中也看到了，体验还是不错的。 原理：Button元素作为父级容器，在其中设置某个子元素的left和top随着点击位置而移动，再加以赋上class=&quot;active&quot;实现波纹特效。这个波纹特效，肉眼看过去还是挺抽象的，其实在参考demo实践一番后才发觉原理并不复杂。 See the Pen Button ripple effect by johnson (@johnsonee) on CodePen. 参考 Material Design 水波纹点按效果]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css Margin分析]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%9E%82%E7%9B%B4%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[在css当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 CSS margin 属性 如果 margin 的值是百分比，则是相对于父元素的内容盒宽度来计算的，即使 margin-top 和 margin-bottom 也是如此。因此即使父元素的高宽不相等，子元素的 margin 元素指定了相同的百分比值，则子元素各个方向的 margin 计算值都是相等的。 margin-top 和 margin-bottom 值对行内非替换元素（non-replaced inline element）是无效的。因此我们可以指定 img 元素的 margin-top 和 margin-bottom，而非替换行内元素（如 i，span 等）设置 margin-top 和 margin-bottom 却不会产生效果。 margin折叠规则 垂直相邻的margin才有可能折叠，水平margin永远不会折叠。 根元素（html元素）的margin永远不折叠。 关于w3c陈述的clearance，由于没很好的理解： If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins of following siblings but that resulting margin does not collapse with the bottom margin of the parent block. 还是通过实践： 浮动元素后的具有clear属性非none的块级元素的border-top会紧贴着浮动元素的margin-bottom，这个闭合浮动的元素和浮动元素的距离由浮动元的margin-bottom决定，但如果这个元素具有margin-top，并且超过浮动元素的高度 + 浮动元素的margin-top + 浮动元素前面元素的margin-bottom + 浮动元素的margin-bottom，那这个时候闭合浮动元素的margin-top实际是和浮动元素的前一个元素产生”化学反应”，大到和浮动元素间产生间距，并且这个距离不受parent元素的margin-bottom影响。详细看demo: 参考链接 w3c规范中的BFC定义浮动元素和绝对定位元素，非块级盒子的块级容器。（例如 inline-blocks, table-cells, table-captions），以及overflow值不为visible的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。 BFC中的元素的布局是不受外界的影响的（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和子元素带来的影响。）并且在一个BFC中，块盒和行盒（行盒由一行中所有的内联元素所组成）都会 垂直的沿着其父元素的边框排列。 折叠结果 两个相邻的外边距都是正数时，折叠结果是它们两者之间的较大值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负，折叠结果是两者的相加的和。 相邻的 margin （Adjoining margin）如果两个垂直方向上的 margin，它们中间没有其他垂直 margin，但它们之间不一定相接触，我们就说这两个 margin 是垂直毗连（vertical-adjacent）的，包括以下四种情况，满足其中之一即可 父元素的 top margin 和第一个子元素的 top margin 父元素的bottom margin 和最后一个子元素的 bottom margin 元素的 bottom margin 和与这个元素相邻的兄弟元素的 top margin 如果一个元素，它没有生成 BFC、没有包含正常流的子元素、min-height是0、height是0或者 auto，则它的 top margin 和 bottom margin 也是垂直毗连的 如果两个 margin 满足以下三个条件，我们就说这两个 margin 是相邻（adjoining）的 这两个 margin 是垂直毗连的，即满足上面四种情况之一 margin 的两个元素都是正常流的块级元素，并且在同一个 BFC 中 两个 margin 之间没有行盒（line box）、清除浮动后的空隙（clearance）、padding和 border 细说 CSS margin 深入理解BFC和Margin Collapse]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http&TCP连接]]></title>
    <url>%2F2018%2F08%2F21%2FHttp%26TCP%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[HTTP协议与TCP/IP协议的关系HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发送端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 如何理解HTTP协议是无状态的Http协议是无状态的，指的是协议对于事务处理是没有记忆能力的，服务器不知道客户端是什么状态的。 什么是持久连接？ 在HTTP/1.0中，默认使用的是短连接。 但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： HTTP1.0中有一个Connection首部字段，它是一个逐跳首部字段。Connection:Keep-Alive，表示希望将此条连接作为持久连接。 1connection: keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。 HTTP1.1中，建立的HTTP请求默认是持久连接的。当Client确定不再需要向Server发送数据时，它可以关闭连接，即在发送首部中添加Connection:Closed字段。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 简而言之：在事务处理结束之后仍然保持打开状态的TCP连接被称为持久连接。非持久连接会在每个事务结束后关闭。 持久连接的一个最大的好处是：大大减少了连接的建立和关闭的时延。多个请求响应在一条连接内完成。 缺点：请求的响应是顺序执行的。需要等到请求1的响应1收到之后，请求2才会发出。这就是持久连接与管道化连接不同的地方 什么是管道化连接？管道化连接是需要持久化连接支持的。管道化连接是在持久连接的基础上，以“流水线”的方式发送请求：不需要等到请求1的响应到达Client，就可以发送请求2…. TCP连接TCP/IP是全球你计算机及其网络设备都在使用的一种常用的分组交换网络协议集。Http要传送一条报文时，会以流的形式将报文数据的内容通过一条已打开的TCP连接按序传输。TCP收到数据流之后，会将数据流砍成被称作段的小数据块，并将其封装在IP分组中，通过因特网进行传输。 网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要3次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。 三次握手示意图： 四次握手关闭图： TCP在其协议头中使用大量的标志位或者说1位（bit）布尔域来控制连接状态，我们最感兴趣的3个标志位如下： SYN - 创建一个连接 FIN - 终结一个连接 ACK - 确认收到数据 一个包中可以有多个标志位。 TCP/IP的可靠性： 无差错的数据传输 按序传输（数据总是会按照发送的顺序到达） 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去） 只要建立了TCP连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接受时出现错序了。 三次握手第一次握手：客户端发送SYN包至服务器，并进入SYN_SENT状态，等待服务器确认。 第二次握手：服务器收到客户端的SYN包，发送一个ACK，同时发送自己的SYN，此时服务器进入SYN_RCVD状态。 第三次握手：客户端接收到服务器发送的SYN+ACK后，进入ESTABLISHED状态，并发送服务器SYN包的确认ACK，服务器接收到客户端ACK后，进入ESTABLISHED状态。 四次挥手第一次挥手：主动关闭方发送一个FIN并进入FIN_WAIT1状态。 第二次挥手：被动关闭方接收到主动关闭方发送的FIN并发送ACK，此时被动关闭方进入CLOSE_WAIT状态；主动关闭方收到被动关闭方的ACK后，进入FIN_WAIT2状态。 第三次挥手：被动关闭方发送一个FIN并进入LAST_ACK状态。 第四次挥手：主动关闭方收到被动关闭方发送的FIN并发送ACK，此时主动关闭方进入TIME_WAIT状态，经过2MSL(Maximum Segment Lifetime - 报文最大生存时间)时间后关闭连接；被动关闭方收到主动关闭方的ACK后，关闭连接。]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
</search>
